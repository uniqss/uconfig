let outputDir = "gen_go";
let goFile = null;

let writeln = function (str) {
    if (str != null) {
        goFile.println(str);
    } else {
        goFile.println();
    }
}

const snake2Pascal = str => {
    str +='';
    str = str.split('_');
    for(let i=0; i<str.length; i++){
        str[i] = str[i].slice(0,1).toUpperCase() + str[i].slice(1,str[i].length);
    }
    return str.join('');
};

function CamelCase(str) {
    return snake2Pascal(str);
}

let transType = function(ctype) {
    if (ctype === "uint32") {
        return "uint32";
    }
    else if (ctype === "string") {
        return "string";
    }
    else if (ctype === "repeated string") {
        return "[]string";
    }
    else if (ctype === "repeated uint32") {
        return "[]uint32";
    }
    else if (ctype === "float") {
        return "float64";
    }
    else if (ctype === "repeated float64") {
        return "[]float";
    }
    else {
        print("type unrecogonized:" + ctype);
    }
}

let getTypeDefault = function(ctype) {
    if (ctype === "uint32") {
        return "0";
    }
    else if (ctype === "float") {
        return "0";
    }
    else if (ctype === "string") {
        return "\"\"";
    }
    else if (ctype === "repeated string") {
        return "nil";
    }
    else if (ctype === "repeated uint32") {
        return "nil";
    }
    else if (ctype === "repeated float64") {
        return "nil";
    }
    else {
        print("type unrecogonized:" + ctype);
    }
}

// Check if a file or directory exists in this path
function exists(file) {
    let ret = os.rename(file, file);
    if (ret === 0) {
        return true;
    }

    // 13 means: Permission denied, but it exists
    return ret === 13;
}
// Check if a directory exists in this path
function isdir(path) {
    // "/" works on both Unix and Windows
    return exists(path + "/");
}

function createDirIfNotExists(path) {
    if (isdir(path)) {
        return;
    }
    os.execute("mkdir " + path);
}

let ProcessOneSheet = function(xlsxName, sheetName, vecNames, vecTypes, vecDescriptions) {
    // print("ProcessOneSheet begin");
    // print("xlsxName:", xlsxName, " sheetName:", sheetName, " vecNames:", vecNames, " vecTypes:", vecTypes, " vecDescriptions:", vecDescriptions);

    createDirIfNotExists(outputDir);

    let count1 = vecNames.length;
    let count2 = vecTypes.length;
    let count3 = vecDescriptions.length;
    let count = Math.min(count1, count2, count3);

    // print("count1:", count1, " count2:", count2, " count3:", count3, " count:", count);

    let filePath = "./" + outputDir + "/" + sheetName + ".go";
    goFile = new FileWriter(filePath);

    if (goFile === undefined || goFile == null) {
        print("filePath:" + filePath + " goFile == nil");
    } else {
        // print("filePath:" + filePath + " goFile not nil");
    }

    writeln("// Code generated by little bull tool. DO NOT EDIT!!!");
    writeln();
    writeln("package DataTables");
    writeln();
    writeln("type " + sheetName + " struct {");

    for (let idx=0;idx < count;idx++) {
        let cname = vecNames[idx];
        // print("idx:", idx, " cname:", cname);
        let ctype = vecTypes[idx];
        // print("idx:", idx, " ctype:", ctype);
        if (cname != null && cname !== "" && ctype != null && ctype !== "" ) {
            ctype = transType(ctype);
            // print("idx:", idx, " ctype:", ctype);
            let cdesc = vecDescriptions[idx];
            // print("idx:", idx, " cdesc:", cdesc);
            let cnameCamel = CamelCase(cname);
            // print("idx:", idx, " cnameCamel:", cnameCamel);
            writeln("\t" + cnameCamel + " " + ctype + "  `db:\"" + cname + "\"` // " + cdesc);
        }
    }
    writeln("}");
    writeln();

    for (let idx = 0;idx < count;idx++) {
    /*
        func (m *DT_Hero_Nature_Config) GetQiRate() []uint32 {
            if m != nil {
                return m.QiRate
            }
            return nil
        }
    */
        let cname = CamelCase(vecNames[idx]);
        let ctype = vecTypes[idx];
        if (cname != null && cname !== "" && ctype !== null && ctype !== "") {
            ctype = transType(ctype);
            writeln("func (m *" + sheetName + ") Get" + cname + "() " + ctype + " {");
            writeln("\tif m != nil {");
            writeln("\t\treturn m." + cname);
            writeln("\t}");
            writeln("\treturn " + getTypeDefault(vecTypes[idx]));
            writeln("}");
            writeln();
        }
    }
    writeln();

    writeln("type " + sheetName + "_Data struct {");

    writeln("\t" + sheetName + "Items map[uint32]*" + sheetName + "");

    writeln("}");
    writeln();

    writeln("func (dt *" + sheetName + "_Data) MakeMap(){");

    writeln("\tdt." + sheetName + "Items = make(map[uint32]*" + sheetName + ")");

    writeln("}");
    writeln();

    writeln("func init() {");
    writeln("\tregister(\"" + sheetName + "\", &" + sheetName + "_Data{}, &" + sheetName + "{})");
    writeln("}");
    writeln();

    writeln("func (dt *" + sheetName + ")FromData(data []interface{}) {");
    let realIdx = 0;
    for (let idx = 0; idx < count;idx++) {
        let cname = CamelCase(vecNames[idx]);
        let ctype = vecTypes[idx];
        if (cname != null && cname !== "" && ctype != null && ctype !== "") {
            ctype = transType(ctype);
            if (ctype === "uint32") {
                writeln("\tdt." + cname + " = DataTableReadUInt32(data, \"" + cname + "\", " + realIdx + ", \"" + sheetName + "\")");
            }
            else if (ctype === "string") {
                writeln("\tdt." + cname + " = DataTableReadString(data, \"" + cname + "\", " + realIdx + ", \"" + sheetName + "\")");
            }
            else if (ctype === "float") {
                writeln("\tdt." + cname + " = DataTableReadFloat(data, \"" + cname + "\", " + realIdx + ", \"" + sheetName + "\")");
            }
            else if (ctype === "[]uint32") {
                writeln("\tdt." + cname + " = DataTableReadUInt32Arr(data, \"" + cname + "\", " + realIdx + ", \"" + sheetName + "\")");
            }
            else if (ctype === "[]string") {
                writeln("\tdt." + cname + " = DataTableReadStringArr(data, \"" + cname + "\", " + realIdx + ", \"" + sheetName + "\")");
            }
            else if (ctype === "[]float") {
                writeln("\tdt." + cname + " = DataTableReadFloatArr(data, \"" + cname + "\", " + realIdx + ", \"" + sheetName + "\")");
            }
            realIdx = realIdx + 1;
        }
    }
    writeln();
    writeln("\tGet" + sheetName + "()." + sheetName + "Items[dt.Id] = dt");
    writeln("}");
    writeln();

    writeln("func Get" + sheetName + "() *" + sheetName + "_Data {");
    writeln("\treturn get(\"" + sheetName + "\").(*" + sheetName + "_Data)");
    writeln("}");

    goFile.close();

    gofmtCmd = "gofmt.exe -w " + filePath;
    os.execute(gofmtCmd);
    // print("gofmtCmd:" + gofmtCmd);
};

ProcessOneSheet