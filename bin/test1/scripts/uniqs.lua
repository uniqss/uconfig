local utility = require("utility")

local outputDirServerCode = "../test1/someproject/server/"
local outputDirJson = "../test1/someproject/config_data/"
local goGlobalFileName = "AllConfigs_gen.go"
local currFile = nil

local function write(str)
    if str ~= nil then
        currFile:write(str)
    end
end
local function writeln(str)
    if str ~= nil then
        currFile:write(str, "\n")
    else
        currFile:write("\n")
    end
end

local typeTransGo = {}
typeTransGo["int"] = "int32"
typeTransGo["string"] = "string"
typeTransGo["intArr"] = "[]int32"
typeTransGo["stringArr"] = "[]string"
typeTransGo["intArrArr"] = "[][]int32"
typeTransGo["stringArrArr"] = "[][]string"
typeTransGo["intArrArrArr"] = "[][][]int32"
typeTransGo["stringArrArrArr"] = "[][][]string"
local function transTypeGo(ctype)
    local value = typeTransGo[ctype]
    if value ~= nil then
        return value
    else
        print("type unrecogonized"..ctype)
        return nil
    end
end
local typeDefaultGo = {}
typeDefaultGo["int"] = "0"
typeDefaultGo["string"] = "\"\""
typeDefaultGo["intArr"] = "nil"
typeDefaultGo["stringArr"] = "nil"
typeDefaultGo["intArrArr"] = "nil"
typeDefaultGo["stringArrArr"] = "nil"
typeDefaultGo["intArrArrArr"] = "nil"
typeDefaultGo["stringArrArrArr"] = "nil"
local function getTypeDefaultGo(ctype)
    local value = typeDefaultGo[ctype]
    if value ~= nil then
        return value
    else
        print("type unrecogonized:"..ctype)
        return nil
    end
end

local function needGenerate(cname, ctype, ccs)
    return cname ~= nil and cname ~= "" and ctype ~= nil and ctype ~= "" and ccs ~= nil and ccs ~= ""
end

local function getCount(vecNames, vecTypes, vecCs)
    -- 取count的最小值
    local count1 = utility.tablelength(vecNames)
    local count2 = utility.tablelength(vecTypes)
    local count3 = utility.tablelength(vecCs)
    local count = math.min(count1, count2)
    count = math.min(count, count3)
    return count
end

local function writeGenerateDeclearation()
    writeln("// Code generated by uconfig. DO NOT EDIT!!!  https://github.com/uniqss/uconfig ")
end

function GenerateServerCodeGo(xlsxName, sheetName, vecDatas)
    print("### GenerateServerCodeGo  xlsxName:" .. xlsxName .. "sheetName:" .. sheetName)
    local vecNames = vecDatas[1]
    local vecTypes = vecDatas[2]
    local vecCs = vecDatas[3]
    local vecDescriptions = vecDatas[4]

    utility.createDirIfNotExists(outputDirServerCode)

    local count = getCount(vecNames, vecTypes, vecCs)

    local filePath = outputDirServerCode .. sheetName..".go"
    
    currFile = io.open(filePath, "w+")
    if currFile == nil then
        print("filePath:"..filePath.." currFile == nil")
        return -1
    else
        --print("filePath:"..filePath.." currFile not nil")
    end

    writeGenerateDeclearation()
    writeln()
    writeln("package ConfigData")
    writeln()
    writeln("import (")
    writeln("\"bufio\"")
    writeln("\"fmt\"")
    writeln("\"io\"")
    writeln("\"os\"")
    writeln("\"strings\"")
    writeln(")")

    writeln("type "..sheetName.." struct {")
    local keyType = ""
    local keyTypeTrans = ""
    local keyName = ""
    
    for idx=1,count do
        local cname = vecNames[idx]
        local ctype = vecTypes[idx]
        local ccs = vecCs[idx]
        local cdesc = vecDescriptions[idx]
        if needGenerate(cname, ctype, ccs) then
            if keyType == "" then keyType = ctype end
            ctype = transTypeGo(ctype)
            if keyTypeTrans == "" then keyTypeTrans = ctype end
            if keyName == "" then keyName = utility.CamelCase(cname) end
            writeln("\t"..utility.CamelCase(cname).." "..ctype.."  `json:\""..cname..",omitempty\"` // "..cdesc)
        end
    end
    writeln("}")
    writeln()

    writeln("var (")
    writeln("arr" .. sheetName .. " []" .. sheetName .. "")
    writeln("map" .. sheetName .. " = make(map[" .. keyTypeTrans .. "]*" .. sheetName .. ")")
    writeln(")")
    writeln()
    
    writeln("func (cfg *" .. sheetName .. ") load(line string, lineIdx int) string {")
    writeln("cells := strings.Split(line, \",\")")
    writeln("var ret string")
    writeln("idx := -1")
    writeln()
    
    for idx=1,count do
        local cname = vecNames[idx]
        local ctype = vecTypes[idx]
        local ccs = vecCs[idx]
        local cdesc = vecDescriptions[idx]
        if needGenerate(cname, ctype, ccs) then
            writeln("idx++")
            cname = utility.CamelCase(cname)
            ctype = utility.CamelCase(ctype)
            writeln("if ret = load"..ctype.."(\"" .. sheetName .. "\", &cfg."..cname..", \""..cname.."\", cells, idx, lineIdx, true); ret != \"\" {")
            writeln("return ret")
            writeln("}")
        end
    end
    
    writeln("return \"\"")
    writeln("}")
    writeln()
    
    writeln("func loadConfigData_" .. sheetName .. "(path string) string {")
    writeln("f, err := os.Open(path + \"" .. sheetName .. ".csv\")")
    writeln("if err != nil {")
    writeln("return \"" .. sheetName .. " os.Open err:\" + err.Error()")
    writeln("}")
    writeln("defer func() {")
    writeln("f.Close()")
    writeln("}()")
    writeln()
    writeln("map" .. sheetName .. " = make(map["..keyTypeTrans.."]*" .. sheetName .. ")")
    writeln()
    writeln("lineIdx := 0")
    writeln("rd := bufio.NewReader(f)")
    writeln("for {")
    writeln("line, _, err := rd.ReadLine()")
    writeln("if err == io.EOF {")
    writeln("break")
    writeln("}")
    writeln("if err != nil {")
    writeln("return \"" .. sheetName .. " rd.ReadLine err:\" + err.Error()")
    writeln("}")
    writeln("cfg := &" .. sheetName .. "{}")
    writeln("result := cfg.load(string(line), lineIdx)")
    writeln("if result != \"\" {")
    writeln("return result")
    writeln("}")
    writeln("_, exists := map" .. sheetName .. "[cfg."..keyName.."]")
    writeln("if exists {")
    writeln("ret := fmt.Sprintf(\"" .. sheetName .. " multiple "..keyName.." found. "..keyName..":%v lineIdx:%v\", cfg."..keyName..", lineIdx)")
    writeln("return ret")
    writeln("}")
    writeln("map" .. sheetName .. "[cfg."..keyName.."] = cfg")
    writeln("lineIdx++")
    writeln("}")
    
    writeln("return \"\"")
    writeln("}")
    writeln()
    
    writeln("func Get" .. sheetName .. "("..keyName.." " .. keyTypeTrans .. ") *" .. sheetName .. " {")
    writeln("ret, _ := map" .. sheetName .. "["..keyName.."]")
    writeln("return ret")
    writeln("}")
    writeln()
    
    writeln("// deprecated")
    writeln("func GetArr" .. sheetName .. "() []" .. sheetName .. " {")
    writeln("return arr" .. sheetName .. "")
    writeln("}")
    writeln()
    
    writeln("// deprecated")
    writeln("func GetMap" .. sheetName .. "() map[" .. keyTypeTrans .. "]*" .. sheetName .. " {")
    writeln("return map" .. sheetName .. "")
    writeln("}")
    writeln()
    
    writeln("// cb return true to break the traversal")
    writeln("func TraversalArr" .. sheetName .. "(cb func(idx int, hello *" .. sheetName .. ") bool) {")
    writeln("for idx, cfg := range arr" .. sheetName .. " {")
    writeln("if cb(idx, &cfg) {")
    writeln("break")
    writeln("}")
    writeln("}")
    writeln("}")
    writeln()
    
    writeln("// cb return true to break the traversal")
    writeln("func TraversalMap" .. sheetName .. "(cb func("..keyName.." " .. keyTypeTrans .. ", hello *" .. sheetName .. ") bool) {")
    writeln("for key, cfg := range map" .. sheetName .. " {")
    writeln("if cb(key, cfg) {")
    writeln("break")
    writeln("}")
    writeln("}")
    writeln("}")
    writeln()

    io.close(currFile)
    
    return 0
end

function GenerateDataCsv(xlsxName, sheetName, vecDatas)
    print("### GenerateDataCsv  xlsxName:" .. xlsxName .. "sheetName:" .. sheetName)
    local vecNames = vecDatas[1]
    local vecTypes = vecDatas[2]
    local vecCs = vecDatas[3]
    local vecDescriptions = vecDatas[4]

    utility.createDirIfNotExists(outputDirJson)

    local count = getCount(vecNames, vecTypes, vecCs)

    local filePath = outputDirJson .. sheetName..".csv"
    
    currFile = io.open(filePath, "w+")
    if currFile == nil then
        print("filePath:"..filePath.." currFile == nil")
        return -1
    else
        --print("filePath:"..filePath.." currFile not nil")
    end

    local keyValue = ""
    
    local jsonDatas = {}
    local rowCount = utility.tablelength(vecDatas)
    
    
    for rowIdx=5,rowCount do
        local row = vecDatas[rowIdx]
        local colCount = utility.tablelength(row)
        local idxMin = math.min(count, colCount)
        local idxMax = math.max(count, colCount)
        print("colCount:" .. colCount .. " idxMin:" .. idxMin .. " idxMax:" .. idxMax)
        
        local firstCol = true
        for idx=1,idxMin do
            local cname = vecNames[idx]
            local ctype = vecTypes[idx]
            local ccs = vecCs[idx]
            if not needGenerate(cname, ctype, ccs) then
                goto continue
            end

            print("needGenerate idx:" .. idx .. " cname:" .. cname .. " ctype:" .. ctype .. " ccs:" .. ccs .. " keyValue:" .. keyValue)

            local cellData = row[idx]
            print("cellData:" .. cellData)
            if firstCol then
                write(cellData)
                firstCol = false
            else
                write("," .. cellData)
            end
 
            ::continue::
        end
        for idx=idxMin+1,idxMax,1 do
            if firstCol then
                firstCol = false
            else
                print("xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx idxMin:" .. idxMin .. " idxMax:" .. idxMax .. " idx:" .. idx)
                write(",")
            end
        end
        
        writeln()
    end

    io.close(currFile)
    
    
    return 0
end

function GenerateClientCodeAndDataJs(xlsxName, sheetName, vecDatas)
    print("###GenerateClientCodeAndDataJs  xlsxName:" .. xlsxName .. "sheetName:" .. sheetName)
    return 0
end

function GenerateGoGlobal(sheetNames)
    utility.PrintTable1(sheetNames)

    utility.createDirIfNotExists(outputDirServerCode)

    local filePath = outputDirServerCode .. goGlobalFileName
    
    currFile = io.open(filePath, "w+")
    if currFile == nil then
        print("filePath:"..filePath.." currFile == nil")
        return -1
    else
        --print("filePath:"..filePath.." currFile not nil")
    end
    
    writeGenerateDeclearation()
    writeln("package ConfigData")
    writeln()
    writeln("func loadConfigDataAll(path string) string {")
    writeln("var result string")
    
    local count = utility.tablelength(sheetNames)
    
    for idx=1,count do
        local sheetName = sheetNames[idx]
        writeln()
        writeln("if result = loadConfigData_" .. sheetName .. "(path); result != \"\" {")
        writeln("return result")
        writeln("}")
    end
    
    
    writeln()
    writeln("return \"\"")
    writeln("}")
    writeln()
    

    io.close(currFile)
    
    return 0
end

function GenerateJsGlobal(sheetNames)
    utility.PrintTable1(sheetNames)
    return 0
end

function CallGoFormatDirectory(sheetNames)
    utility.PrintTable1(sheetNames)
    
    local filePath = outputDirServerCode
    
    gofmtCmd = "gofmt.exe -w "..filePath
    os.execute(gofmtCmd)
    print("gofmtCmd:"..gofmtCmd)
    
    return 0
end
