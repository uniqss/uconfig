local utility = require("utility")
local JSON = require("JSON")

local outputDirServerCode = "../test1/someproject/server/"
local outputDirJson = "../test1/someproject/config_data/"
local goGlobalFileName = "AllConfigs_gen.go"
local currFile = nil

local function writeln(str)
    if str ~= nil then
        currFile:write(str, "\n")
    else
        currFile:write("\n")
    end
end

local typeTransGo = {}
typeTransGo["int"] = "int32"
typeTransGo["string"] = "string"
typeTransGo["intArr"] = "[]int32"
typeTransGo["stringArr"] = "[]string"
typeTransGo["intArrArr"] = "[][]int32"
typeTransGo["stringArrArr"] = "[][]string"
typeTransGo["intArrArrArr"] = "[][][]int32"
typeTransGo["stringArrArrArr"] = "[][][]string"
local function transTypeGo(ctype)
    local value = typeTransGo[ctype]
    if value ~= nil then
        return value
    else
        print("type unrecogonized"..ctype)
        return nil
    end
end
local typeDefaultGo = {}
typeDefaultGo["int"] = "0"
typeDefaultGo["string"] = "\"\""
typeDefaultGo["intArr"] = "nil"
typeDefaultGo["stringArr"] = "nil"
typeDefaultGo["intArrArr"] = "nil"
typeDefaultGo["stringArrArr"] = "nil"
typeDefaultGo["intArrArrArr"] = "nil"
typeDefaultGo["stringArrArrArr"] = "nil"
local function getTypeDefaultGo(ctype)
    local value = typeDefaultGo[ctype]
    if value ~= nil then
        return value
    else
        print("type unrecogonized:"..ctype)
        return nil
    end
end

local function needGenerate(cname, ctype, ccs)
    return cname ~= nil and cname ~= "" and ctype ~= nil and ctype ~= "" and ccs ~= nil and ccs ~= ""
end

local function getCount(vecNames, vecTypes, vecCs)
    -- 取count的最小值
    local count1 = utility.tablelength(vecNames)
    local count2 = utility.tablelength(vecTypes)
    local count3 = utility.tablelength(vecCs)
    local count = math.min(count1, count2)
    count = math.min(count, count3)
    return count
end

function GenerateServerCodeGo(xlsxName, sheetName, vecDatas)
    print("###GenerateServerCodeGo  xlsxName:" .. xlsxName .. "sheetName:" .. sheetName)
    local vecNames = vecDatas[1]
    local vecTypes = vecDatas[2]
    local vecCs = vecDatas[3]
    local vecDescriptions = vecDatas[4]

    utility.createDirIfNotExists(outputDirServerCode)

    local count = getCount(vecNames, vecTypes, vecCs)

    local filePath = outputDirServerCode .. sheetName..".go"
    
    currFile = io.open(filePath, "w+")
    if currFile == nil then
        print("filePath:"..filePath.." currFile == nil")
        return -1
    else
        --print("filePath:"..filePath.." currFile not nil")
    end

    writeln("// Code generated by uconfig. DO NOT EDIT!!!")
    writeln()
    writeln("package ConfigData")
    writeln()
    writeln("import (")
    writeln("\"fmt\"")
    writeln("jsoniter \"github.com/json-iterator/go\"")
    writeln("\"io/ioutil\"")
    writeln(")")

    writeln("type "..sheetName.." struct {")
    local keyType = ""
    local keyTypeTrans = ""
    
    for idx=1,count do
        local cname = vecNames[idx]
        local ctype = vecTypes[idx]
        local ccs = vecCs[idx]
        local cdesc = vecDescriptions[idx]
        if needGenerate(cname, ctype, ccs) then
            if keyType == "" then keyType = ctype end
            ctype = transTypeGo(ctype)
            if keyTypeTrans == "" then keyTypeTrans = ctype end
            writeln("\t"..utility.CamelCase(cname).." "..ctype.."  `json:\""..cname..",omitempty\"` // "..cdesc)
        end
    end
    writeln("}")
    writeln()

    writeln("var (")
    writeln("arr" .. sheetName .. " []" .. sheetName .. "")
    writeln("map" .. sheetName .. " = make(map[" .. keyTypeTrans .. "]*" .. sheetName .. ")")
    writeln(")")
    writeln()
    
    writeln("func loadConfigData_" .. sheetName .. "(path string) string {")
    writeln("contentBytes, err := ioutil.ReadFile(path + \"" .. sheetName .. ".json\")")
    writeln("if err != nil {")
    writeln("return \"" .. sheetName .. " ioutil.ReadFile err:\" + err.Error()")
    writeln("}")
    writeln()
    writeln("var json = jsoniter.ConfigCompatibleWithStandardLibrary")
    writeln("err = json.Unmarshal(contentBytes, arr" .. sheetName .. ")")
    writeln("if err != nil {")
    writeln("return \"" .. sheetName .. " json.Unmarshal err:\" + err.Error()")
    writeln("}")
    writeln()
    writeln("map" .. sheetName .. " = make(map[" .. keyTypeTrans .. "]*" .. sheetName .. ")")
    writeln("for idx, cfg := range arr" .. sheetName .. " {")
    writeln("_, exists := map" .. sheetName .. "[cfg.Id]")
    writeln("if exists {")
    writeln("ret := fmt.Sprintf(\"" .. sheetName .. " multiple id found. Id:%v idx:%v\", cfg.Id, idx)")
    writeln("return ret")
    writeln("}")
    writeln("map" .. sheetName .. "[cfg.Id] = &cfg")
    writeln("}")
    writeln()
    writeln("return \"\"")
    writeln("}")
    writeln()
    writeln("func Get" .. sheetName .. "(id " .. keyTypeTrans .. ") *" .. sheetName .. " {")
    writeln("ret, _ := map" .. sheetName .. "[id]")
    writeln("return ret")
    writeln("}")
    writeln()
    writeln("// deprecated")
    writeln("func GetArr" .. sheetName .. "() []" .. sheetName .. " {")
    writeln("return arr" .. sheetName .. "")
    writeln("}")
    writeln()
    writeln("// deprecated")
    writeln("func GetMap" .. sheetName .. "() map[" .. keyTypeTrans .. "]*" .. sheetName .. " {")
    writeln("return map" .. sheetName .. "")
    writeln("}")
    writeln()
    writeln("// cb return true to break the traversal")
    writeln("func TraversalArr" .. sheetName .. "(cb func(idx int, hello *" .. sheetName .. ") bool) {")
    writeln("for idx, cfg := range arr" .. sheetName .. " {")
    writeln("if cb(idx, &cfg) {")
    writeln("break")
    writeln("}")
    writeln("}")
    writeln("}")
    writeln()
    writeln("func TraversalMap" .. sheetName .. "(cb func(id " .. keyTypeTrans .. ", hello *" .. sheetName .. ") bool) {")
    writeln("for key, cfg := range map" .. sheetName .. " {")
    writeln("if cb(key, cfg) {")
    writeln("break")
    writeln("}")
    writeln("}")
    writeln("}")
    writeln()

    io.close(currFile)
    
    return 0
end

function GenerateServerDataJson(xlsxName, sheetName, vecDatas)
    print("###GenerateServerDataJson  xlsxName:" .. xlsxName .. "sheetName:" .. sheetName)
    local vecNames = vecDatas[1]
    local vecTypes = vecDatas[2]
    local vecCs = vecDatas[3]
    local vecDescriptions = vecDatas[4]

    utility.createDirIfNotExists(outputDirJson)

    local count = getCount(vecNames, vecTypes, vecCs)

    local filePath = outputDirJson .. sheetName..".json"
    
    currFile = io.open(filePath, "w+")
    if currFile == nil then
        print("filePath:"..filePath.." currFile == nil")
        return -1
    else
        --print("filePath:"..filePath.." currFile not nil")
    end

    local keyValue = ""
    
    local jsonDatas = {}
    local rowCount = utility.tablelength(vecDatas)
    
    
    for rowIdx=5,rowCount do
        local jsonData = {}
        local row = vecDatas[rowIdx]
        local colCount = utility.tablelength(row)
        print("colCount:" .. colCount)
        local idxMax = math.min(count, colCount)
        for idx=1,idxMax do
            local cname = vecNames[idx]
            local ctype = vecTypes[idx]
            local ccs = vecCs[idx]
            if not needGenerate(cname, ctype, ccs) then
                goto continue
            end
            
            print("needGenerate idx:" .. idx .. " cname:" .. cname .. " ctype:" .. ctype .. " ccs:" .. ccs .. " keyValue:" .. keyValue)
            
            local cellData = row[idx]
            print("cellData:" .. cellData)
            
            if ctype == "int" then
                if keyValue == "" then keyValue = cellData end
                jsonData[cname] = cellData
            elseif ctype == "string" then
                if keyValue == "" then keyValue = cellData end
                jsonData[cname] = cellData
--            elseif ctype == "intArr" then
--                local tb = utility.Split(cellData, "|")
--                jsonData[cname] = tb
--            elseif ctype == "stringArr" then
--                local tb = utility.Split(cellData, "|")
--                jsonData[cname] = tb
--            elseif ctype == "intArrArr" then
--                local tb = {}
--                local tbsp1 = utility.Split(cellData, "#")
--                for idxtb1=1,#tbsp1 do
--                    local tbsp2 = utility.Split(tbsp1[idxtb1], "|")
--                    tb[#tb+1]=tbsp2
--                end
                
--                jsonData[cname] = tb
--            elseif ctype == "stringArrArr" then
--                local tb = {}
--                local tbsp1 = utility.Split(cellData, "#")
--                for idxtb1=1,#tbsp1 do
--                    local tbsp2 = utility.Split(tbsp1[idxtb1], "|")
--                    tb[#tb+1]=tbsp2
--                end
                
--                jsonData[cname] = tb
--            elseif ctype == "intArrArrArr" then
--                local tb = {}
--                local tbsp1 = utility.Split(cellData, "+")
--                for idxtb1=1,#tbsp1 do
--                    local tb2 = {}
--                    local tbsp2 = utility.Split(tbsp1[idxtb1], "#")
--                    for idxtb2=1,#tbsp2 do
--                        local tbsp3 = utility.Split(tbsp2[idxtb2], "|")
--                        tb2[#tb2+1]=tbsp3
--                    end
                    
--                    tb[#tb+1]=tb2
--                end
                
--                jsonData[cname] = tb
--            else if ctype == "stringArrArrArr" then
--                local tb = {}
--                local tbsp1 = utility.Split(cellData, "+")
--                for idxtb1=1,#tbsp1 do
--                    local tb2 = {}
--                    local tbsp2 = utility.Split(tbsp1[idxtb1], "#")
--                    for idxtb2=1,#tbsp2 do
--                        local tbsp3 = utility.Split(tbsp2[idxtb2], "|")
--                        tb2[#tb2+1]=tbsp3
--                    end
                    
--                    tb[#tb+1]=tb2
--                end
                
--                jsonData[cname] = tb
            end
                
            ::continue::
        end
        print("keyValue:"..keyValue)
        print("1111")
        print(jsonData)
        print("2222")
        jsonDatas[keyValue]=jsonData
        print("3333")
        keyValue = ""
    end
    
    --print("jsonDatas:"..jsonDatas)
    print("44444")
    
    fuckTable = {}
    fuckTable["fuck"] = "shit"
    local jsonString = JSON:encode(fuckTable)
    
    print("55555")
    
    writeln(jsonString)
    
    print("66666")
    

    io.close(currFile)
    
    
    return 0
end

function GenerateClientCodeAndDataJs(xlsxName, sheetName, vecDatas)
    print("###GenerateClientCodeAndDataJs  xlsxName:" .. xlsxName .. "sheetName:" .. sheetName)
    return 0
end

function GenerateGoGlobal(sheetNames)
    utility.PrintTable1(sheetNames)

    utility.createDirIfNotExists(outputDirServerCode)

    local filePath = outputDirServerCode .. goGlobalFileName
    
    currFile = io.open(filePath, "w+")
    if currFile == nil then
        print("filePath:"..filePath.." currFile == nil")
        return -1
    else
        --print("filePath:"..filePath.." currFile not nil")
    end
    
    
    writeln("package ConfigData")
    writeln()
    writeln("func loadConfigDataAll(path string) string {")
    writeln("var result string")
    
    local count = utility.tablelength(sheetNames)
    
    for idx=1,count do
        local sheetName = sheetNames[idx]
        writeln()
        writeln("if result = loadConfigData_" .. sheetName .. "(path); result != \"\" {")
        writeln("return result")
        writeln("}")
    end
    
    
    writeln()
    writeln("return \"\"")
    writeln("}")
    writeln()
    

    io.close(currFile)
    
    return 0
end

function GenerateJsGlobal(sheetNames)
    utility.PrintTable1(sheetNames)
    return 0
end

function CallGoFormatDirectory(sheetNames)
    utility.PrintTable1(sheetNames)
    
    local filePath = outputDirServerCode
    
    gofmtCmd = "gofmt.exe -w "..filePath
    os.execute(gofmtCmd)
    print("gofmtCmd:"..gofmtCmd)
    
    return 0
end
